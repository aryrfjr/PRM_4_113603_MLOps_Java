import { APP_ID, Component, OnInit, ViewChild } from '@angular/core';

import { finalize } from 'rxjs/operators';

import { NominalCompositionService } from '../../core/services/nominal-composition.service';
import { RunService } from '../../core/services/run.service';
import { SubRunService } from '../../core/services/sub-run.service';
import { DataOpsService } from '../../core/services/data-ops.service';
import { NominalComposition } from '../../core/models/nominal-composition.model';
import { Run } from '../../core/models/run.model';
import { SubRunsDataTableComponent } from '../shared/components/sub-runs-datatable/sub-runs-datatable.component';
import { GEOMETRIC_TRANSFORMATIONS, GeometricTransformation } from '../shared/components/geometric-transformations/geometric-transformations';
import { RunExploitationRequest } from '../../core/models/run-exploitation-request.model';

@Component({
  selector: 'app-pre-deployment-exploitation',
  templateUrl: './pre-deployment-exploitation.component.html',
  styleUrls: ['./pre-deployment-exploitation.component.css']
})

export class PreDeploymentExploitationComponent implements OnInit {

  //
  // Support to a kind of ViewModel from MVVM (Model-View-ViewModel) approach
  //
  //////////////////////////////////////////////////////

  get uiState() {

    return {
      displayLoadingMessage: this.serviceRequestOn,
      displayScheduleForm: !this.serviceRequestOn && this.selectedNominalCompositionId != null,
      displaySubRunsTable: this.selectedRunId != null,
      displayGeomTransfCheckboxes: this.selectedRunId != null,
      suggestRunSelection: !this.serviceRequestOn && this.selectedRunId === null,
      isTabScheduleActive: this.activeTab === 'tab1',
      isTabViewActive: this.activeTab === 'tab2',
      displayAlertMessage: this.serviceRequestErrorMessage != null || this.scheduleSuccessMessage != null,
      alertMessageType: this.serviceRequestErrorMessage != null ? "error" : this.scheduleSuccessMessage != null ? "success" : null,
      alertMessage: this.serviceRequestErrorMessage ?? this.scheduleSuccessMessage ?? null
    };

  }

  // NOTE: a way to clean SubRuns information
  @ViewChild(SubRunsDataTableComponent)
  subRunsDataTableComponent!: SubRunsDataTableComponent;
  
  // Messages and flags related to data operations
  serviceRequestOn = false;
  serviceRequestErrorMessage: string | null = null;
  scheduleSuccessMessage: string | null = null;

  //
  // Attributes related to the drop-down with Nominal Compositions
  //
  //////////////////////////////////////////////////////

  allNominalCompositions: NominalComposition[] = [];
  selectedNominalCompositionId: number | null = null;
  selectedNominalCompositionName: string | null = null;
  selectedRuns: Run[] = [];
  selectedRunId: number | null = null;
  selectedRunNumber: number | null = null;
  
  //
  // Attributes related to the checkboxes
  //
  //////////////////////////////////////////////////////
  
  allGeomTransfTypes: GeometricTransformation[] = GEOMETRIC_TRANSFORMATIONS;

  allRunsGeomTransfCurrentSelection = new Map<number, Set<number>>();
  allRunsGeomTransfAlreadyScheduled = new Map<number, Set<number>>();
  
  get runGeomTransfCurrentSelections(): Set<number> | null {

    // If there is no Run selected
    if (!this.selectedRunId) return null;

    // First time selecting Geometric Transformations for current Run ID
    if (!this.allRunsGeomTransfCurrentSelection.has(this.selectedRunId)) {
      this.allRunsGeomTransfCurrentSelection.set(this.selectedRunId, new Set());
    }

    // The Geometric Transformations already selected for current Run ID in current selection
    return this.allRunsGeomTransfCurrentSelection.get(this.selectedRunId)!;
    
  }

  get runGeomTransfPreviousSelections(): Set<number> | null {

    // If there is no Run selected
    if (!this.selectedRunId) return null;

    // First time selecting Geometric Transformations for current Run ID
    if (!this.allRunsGeomTransfAlreadyScheduled.has(this.selectedRunId)) {
      this.allRunsGeomTransfAlreadyScheduled.set(this.selectedRunId, new Set());
    }

    // The Geometric Transformations already selected for current Run ID in current selection
    return this.allRunsGeomTransfAlreadyScheduled.get(this.selectedRunId)!;
    
  }

  //
  // Attributes for the Tabs
  //
  //////////////////////////////////////////////////////

  activeTab: 'tab1' | 'tab2' = 'tab1';

  //
  // Component related methods
  //
  //////////////////////////////////////////////////////

  constructor(// NOTE: All these dependencies will be injected.
    private nominalCompositionService: NominalCompositionService,
    private runService: RunService,
    private subRunService: SubRunService,
    private dataOpsService: DataOpsService
  ) {}

  ngOnInit(): void {

    this.startedServiceRequest()

    // Loading the Nominal Compositions for the corresponding drop-down
    this.nominalCompositionService.getAll().pipe(
      finalize(() => {
        this.finalizedServiceRequest();
      })
    ).subscribe({
      next: (data) => {
        this.allNominalCompositions = data
      },
      error: (err) => {
        console.error('Failed to fetch Nominal Compositions', err)
        this.serviceRequestErrorMessage = `Failed to fetch Nominal Compositions. Error: ${err?.error?.message}`;
      }
    });

  }

  cleanMessages(): void {
    this.serviceRequestErrorMessage = null;
    this.scheduleSuccessMessage = null;
  }

  startedServiceRequest(): void {
    this.serviceRequestOn = true;
    this.cleanMessages();
  }

  finalizedServiceRequest(): void {
    this.serviceRequestOn = false;
  }

  //
  // Methods related to the two tabs
  //
  //////////////////////////////////////////////////////

  activateTab2(): void {

    this.activeTab = 'tab2';

    if (this.selectedNominalCompositionId) {
      this.fetchRunsForSelectedComposition();
      this.cleanMessages();
    }

  }

  //
  // Methods related to input "Select Nominal Composition"
  //
  //////////////////////////////////////////////////////

  onNominalCompositionSelected(nominalId: number): void {

    // NOTE: The + coerces nominalId to a number
    this.selectedNominalCompositionId = nominalId;
    this.selectedNominalCompositionName = this.allNominalCompositions.find(nc => nc.id === +nominalId)?.name ?? null;

    this.fetchRunsForSelectedComposition();
    this.cleanMessages();

    // Cleaning up checkboxes
    this.allRunsGeomTransfCurrentSelection = new Map<number, Set<number>>();
    this.allRunsGeomTransfAlreadyScheduled = new Map<number, Set<number>>();

    // Cleaning up selected Run information
    this.selectedRunId = null;
    this.selectedRunNumber = null;

  }

  private fetchRunsForSelectedComposition(): void {

    if (!this.selectedNominalCompositionId) return;

    this.startedServiceRequest();

    this.runService.getAll(this.selectedNominalCompositionId).pipe(
      finalize(() => {
        this.finalizedServiceRequest();
      })
    ).subscribe({
        next: (data) => {
          this.selectedRuns = data;
        },
        error: (err) => {
          console.error('Failed to fetch Runs', err);
          this.serviceRequestErrorMessage = `Failed to fetch Runs. Error: ${err?.error?.message}`;
        }
      });

  }

  //
  // Methods related to input "select Run #"
  //
  //////////////////////////////////////////////////////

  onRunSelected(runId: number | string | null): void {

    this.selectedRunId = runId !== null ? +runId : null;
    this.selectedRunNumber = this.selectedRuns.find(run => run.id === Number(runId))?.run_number ?? null;
    
    /*
    * NOTE: setTimeout will push the call to the child method to the end 
    *   of the event loop, letting Angular render the *ngIf content before 
    *   it executes. This was added because the following error was in the 
    *   console: "ERROR TypeError: this.subRunsDataTableComponent is undefined".
    */
    setTimeout(() => {
      if (this.subRunsDataTableComponent) {
        // NOTE: a way to clean SubRuns information using @ViewChild (see above)
        this.subRunsDataTableComponent.cleanSubRunsInfo();
      }
    });

    // TODO: that information just loaded could be injected
    //  in the chield subRunsDataTableComponent, since that
    //  component will query the same set one more time
    this.fetchSubRunsForSelectedRun();

  }

  //
  // Methods related to the checkboxes
  //
  //////////////////////////////////////////////////////

  onCheckboxChange(event: Event, index: number) {

    if (!this.runGeomTransfCurrentSelections) return;

    const target = event.target as HTMLInputElement;

    const isChecked = target.checked;

    if (isChecked) {
      this.runGeomTransfCurrentSelections.add(index);
    } else {
      this.runGeomTransfCurrentSelections.delete(index);
    }

  }

  isChecked(index: number): boolean {
    return (this.runGeomTransfCurrentSelections?.has(index) || this.runGeomTransfPreviousSelections?.has(index)) ?? false;
  }

  isDisabled(index: number): boolean {
    return this.runGeomTransfPreviousSelections?.has(index) ?? false;
  }

  // TODO: replicated in the component SubRunsDataTable. The set of SubRuns
  //  could be injected in the chield subRunsDataTableComponent, since that
  //  component will query the same set one more time.
  private fetchSubRunsForSelectedRun(): void {

    if (!this.selectedRunId) return;

    this.startedServiceRequest();

    this.subRunService.getAll(this.selectedRunId).pipe(
      finalize(() => {
        this.finalizedServiceRequest();
      })
    ).subscribe({
        next: (data) => {
           // Loading the corresponding sub-Runs that were already scheduled
          if (data && this.selectedRunId != null) {
            this.allRunsGeomTransfAlreadyScheduled.set(this.selectedRunId, 
              new Set(data.map(run => run.sub_run_number)));
          }
        },
        error: (err) => {
          console.error('Failed to fetch SubRuns', err);
          this.serviceRequestErrorMessage = `Failed to fetch SubRuns. Error: ${err?.error?.message}`;
        }
      });

  }

  // Schedule Runs
  scheduleSubRuns(): void {

    this.startedServiceRequest();

    const payload: RunExploitationRequest = {
      runs: Array.from(this.allRunsGeomTransfCurrentSelection.entries()).map(([runId, subRunSet]) => {
        const run = this.selectedRuns.find(r => r.id === runId);
        return {
          id: runId,
          runNumber: run?.run_number ?? -1,
          subRuns: Array.from(subRunSet),
        };
      })
    };

    this.dataOpsService.generate_exploit(this.selectedNominalCompositionName ?? "", payload).pipe(
      finalize(() => {
        this.finalizedServiceRequest();
      })
    ).subscribe({
      next: () => {
        this.scheduleSuccessMessage = `The following sub-Run(s) have been scheduled for 
        Nominal Composition '${this.selectedNominalCompositionName}': ${payload}. 
        Check in the tab 'View all scheduled sub-Runs'.`;
      },
      error: (err) => {
        this.serviceRequestErrorMessage = `Failed to schedule sub-Runs for 
        Nominal Composition '${this.selectedNominalCompositionName}'. Error: ${err?.error?.message}`;
        console.error('Pre-Deployment Exploitation error:', err);
      }
    });

  }

}
